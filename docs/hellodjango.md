# Introduction to Django

Here, Nelson draws his diagram on the board:

Client      ↰
 ↓          ↑
URLConf  HttpRequest
 ↓          ↑
views  → template
 ↓  ↑
models
 ↓  ↑
database

- - -

## Setting up the Django environment

Cool. So now, let's write a hello world application in Django. The first thing we need to do is describe what our application should do. This is pretty simple: when we go to any url matching the pattern /hello/{name}/, we want to see the text "Hello, {name}," substituting {name} for what's actually there. So, for instance, /hello/Rodney/ should return "Hello, Rodney."

Before that, though, we need to set up a Django environment. How you do that will depend on how you have Django installed.

(Really quick: I'll ask you to type things into your terminal, and it'll look like

`(venv)$ some_command maybe some other-stuff`

Don't type the stuff before $, but type everything else. The $ just indicates a terminal prompt)

Open up a terminal and type 

`$ which virtualenv`

If you get a line saying something like

> which virtualenv: /usr/bin/virtualenv

then you have virtualenv installed. You're good - just chill for now.

On the other hand, if you get a blank line or an error saying "virtualenv not found," you need to install the `python-virtualenv` package with your favorite package manager. For Ubuntu and Debian, this is aptitude; for Fedora and CentOS, yum; for Arch, pacman. Unfortunately, if you're running Windows or Mac, I don't know how to install virtualenv on those platforms.

Once you have virtualenv, in a terminal:

`$ mkdir Django-Workshop && cd Django-Workshop`

`$ virtualenv venv --distribute`

`$ source venv/bin/activate`

`(venv)$ pip install Django`

This sets up an isolated virtual environment that only contains python and Django. Even though it takes a couple of extra steps to set up, it's a lot easier to maintain dependencies between packages this way, compared to installing everything globally. Plus, configuring your Django setup using virtualenv lets you push code live to Heroku in two steps.

Now that you have a Django setup ready to go, it's time to create your first Django project! 

`(venv)$ django-admin.py startproject hellodjango`

Now if you run a directory listing, you'll see that there's a new directory called hellodjango. It contains the bare bones required to run a Django application. In fact, you can run

`(venv)$ python hellodjango/manage.py runserver`

> Validating models...
> 
> 
> 
> 0 errors found
> 
> Django version 1.3.1, using settings 'hellodjango.settings'
> 
> Development server is running at http://127.0.0.1:8000/
> 
> Quit the server with CONTROL-C.

Now, if you open your browser and go to http://127.0.0.1:8000/, you'll see a nifty "It Worked!" page. Of course, as the page reminds you, you haven't done any work yet. We're about to get some done, though, so open a new terminal, `$ source venv/bin/activate`, and we'll get down to it.

Let's see what files django-admin.py created when we told it to make our new project. There are four: \_\_init\_\_.py, manage.py, settings.py, and urls.py. You can ignore the first two files, \_\_init\_\_ and manage - init is empty and manage is an autogenerated script that makes it easy to do development work. I'll get to that later.

Settings.py is a bunch of, well, settings that Django uses for different thngs around the framework. It comes with reasonable defaults, so we can ignore it as well right now.

## Url patterns

The main file we want to look at is urls.py. Let's do that. It consists of three parts. The first one is an import statement for three functions we'll use in a bit. The second part is a commented-out section about an admin interface. Django comes with a really, really nice built-in web interface to manage data in the database, but we're not using the database for this hello world app, so we can ignore the admin.

The third part is the important part. This is the list of url patterns that tells Django how to handle every incoming request. Ignore the `patterns` and `url` functions for now and just pretend that they mean lists and tuples, respectively. Let's look at an individual url pattern and see how it's structured.

We can see it's in three parts. The first part is a regular expression, the second part is a string that references a Django view, and the third part is optional arguments. This is how Django figures out what to do with each request. It checks the resource -- the part after the domain name -- against all the regular expressions, and once it finds its first match, calls the Django view. I'll get to the view in a sec - for now, let's write a url pattern for our hello world application.

Remember, we want it to match /hello/{name}, where {name} can be any name at all.

    url(r'^hello/{name}/$', 'hellodjango.views.sayhi', name='sayhi'),

Unfortunately, since we have to use regular expressions, we can't just make {name} part of the url pattern because that would only match /hello/n/. Fortunately, regular expressions have something called a named capture group. Without going into the gory details, it's a way to "name" a part of a regular expression and save it to use somewhere else. Let's change our current url pattern to use a named capture group.

    url(r'^hello/(?P<name>.*)/$', 'hellodjango.views.sayhi', name='sayhi'),

You don't have to memorize the syntax for named capture groups, but it's pretty intuitive when you see it. Put parentheses around what you want to capture, and question-mark-P names the capture. We'll see how to use the captured name in the next section, the view.

## The view

If you open http://127.0.0.1:8000/hello/world/ right now, you'll notice the nice "It Worked!" page is gone, replaced with an error message and stack trace. Django errors are generally really verbose, which is fantastic when you're debugging. In this case, the error message is

> ViewDoesNotExist at /hello/world/
> 
> Could not import hellodjango.views. Error was: No module named views

What Django is telling us here is that it matched the request to a url pattern (the /hello/{name} pattern we just wrote) but it couldn't find the views module of hellodjango. That's because we haven't created it yet -- let's do that now.

In the hellodjango folder, create a new file called `views.py` and open it for editing. Make a new Python function `sayhi` that takes two arguments: `req` and `name`.

    def sayhi(req, name):
       return "Hello, "+name

Now if you open http://127.0.0.1:8000/hello/world/, you'll see a new error message:

> AttributeError at /hello/world/
> 
> 'unicode' object has no attribute 'status_code'

This one is a bit less intuitive than View Does Not Exist, but that's because I haven't talked about how Django deals with HTTP yet. That's about to change.

To make dealing with HTTP requests and responses much, much easier, Django provides two classes: `HttpRequest` and `HttpResponse`. The first one is an abstraction of the request a client browser makes to your Django application; the second one is an abstraction of the response your application returns to the client browser. You can access all sorts of values from a `HttpRequest` object, like `.method`, which returns the Http method (GET, POST, etc) used to access the page, or `.user`, which refers to the current user in your app; and you can set all sorts of values on a `HttpResponse` object, like `.status_code`, which is the Http status code (200, 404, etc) for your document. Hmm, where have we seen `.status_code` recently? Oh, right. In the error message we just got.

The golden rule of Django's views is that each view should always get passed a `HttpRequest` object  and each view should always return a `HttpResponse` object. Always. If we look back to our hellodjango/views.py, the `sayhi` function doesn't return a `HttpResponse` object -- in fact, it doesn't even know what that is. Let's import it into views.py. At the top of the file, add

    from django.http import HttpResponse

So now views.py knows about HttpResponse, but `sayhi` still isn't returning one. Since `HttpResponse` is just a wrapper around the response text, change `sayhi`'s return line to wrap a `HttpResponse` object around "Hello...":

        return HttpResponse("Hello, "+name)

And that's it! Open your browser back up, and head to http://127.0.0.1:8000/hello/world/. There's the glorious "Hello, world!" waiting for you. Change /hello/world/ to /hello/Rodney/, and Django will say hi to me instead.

Of course, this has just been the absolute basics of Django. There's so much more you can do with it -- we haven't touched on database models, or templates, or customizing the site for logged-in users. Yet. But we're about to blow your minds.

## Get ready to blow your mind


